<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flux Desk</title>

<style>
:root {
  --bg: #0b0e13;
  --panel: #141821;
  --panel-hi: #1b2130;
  --text: #d6d8dc;
  --muted: #8b90a0;
  --accent: #5eead4;
}

* { box-sizing: border-box; }

html, body {
  margin: 0;
  height: 100%;
  background: radial-gradient(1200px at top, #10151f, #080a0f);
  color: var(--text);
  font-family: system-ui, -apple-system, Segoe UI, sans-serif;
  overflow: hidden;
}

/* ===== Command Rail ===== */
#rail {
  height: 46px;
  background: linear-gradient(180deg, #141821, #0f131b);
  display: flex;
  align-items: center;
  padding: 0 14px;
}

#rail span {
  color: var(--muted);
  margin-right: 12px;
  letter-spacing: 0.4px;
}

#bytecode {
  flex: 1;
  height: 28px;
  background: #07090d;
  color: var(--accent);
  border-radius: 8px;
  border: none;
  padding: 0 10px;
  font-family: monospace;
  outline: none;
}

/* ===== Canvas ===== */
#canvas {
  position: absolute;
  top: 46px;
  bottom: 0;
  left: 0;
  right: 0;
}

/* ===== Node ===== */
.node {
  position: absolute;
  width: 380px;
  height: 280px;
  background: linear-gradient(180deg, var(--panel-hi), var(--panel));
  border-radius: 18px;
  box-shadow:
    0 18px 40px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.03);
  display: flex;
  flex-direction: column;
  resize: both;
  overflow: hidden;
}

.node.focused {
  box-shadow:
    0 0 36px rgba(94,234,212,.35),
    0 30px 60px rgba(0,0,0,.75);
}

/* ===== Header ===== */
.node-header {
  height: 36px;
  background: linear-gradient(180deg, #1f2534, #151a25);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 14px;
  font-size: 13px;
  color: var(--muted);
  cursor: move;
  user-select: none;
}

.controls span {
  margin-left: 10px;
  font-family: monospace;
  cursor: pointer;
  opacity: .6;
}
.controls span:hover { opacity: 1; }

/* ===== Terminal ===== */
.terminal {
  flex: 1;
  background: radial-gradient(900px at top, #05070c, #000);
  color: var(--text);
  font-family: monospace;
  font-size: 13px;
  padding: 14px;
  overflow-y: auto;
}
</style>
</head>

<body>

<div id="rail">
  <span>flux</span>
  <input id="bytecode" placeholder="TERM 1 FORMAT <<EOF ... (use \\n for newlines)">
</div>

<div id="canvas"></div>

<script>
const canvas = document.getElementById("canvas");
const input = document.getElementById("bytecode");
const terminals = {};
let z = 1;

/* ===== NEWLINE DECODER (transport layer) =====
   - user types literal \n in the bytecode input
   - we convert \\n -> actual newline char
   - leaves real newlines alone (if any exist)
*/
function decodeEscapes(s) {
  return s
    .replace(/\\n/g, "\n")
    .replace(/\\t/g, "\t")
    .replace(/\\r/g, "\r");
}

/* ===== FORMAT RENDERER (safe, semantic) ===== */
function renderFormat(text) {
  const colors = {
    red:"#ff6b6b", green:"#6bff95", yellow:"#f5c26b",
    blue:"#6fa8ff", magenta:"#c77dff", cyan:"#5eead4",
    gray:"#9aa0aa", white:"#ffffff"
  };

  // escape HTML
  let out = text
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");

  // headers
  out = out.replace(/^## (.*)$/gm,
    "<div style='font-size:14px;font-weight:600;margin-top:6px'>$1</div>");
  out = out.replace(/^# (.*)$/gm,
    "<div style='font-size:16px;font-weight:700;margin-top:10px'>$1</div>");

  // bold / dim
  out = out.replace(/\*\*(.*?)\*\*/g, "<span style='font-weight:650'>$1</span>");
  out = out.replace(/~~(.*?)~~/g, "<span style='opacity:.55'>$1</span>");

  // divider
  out = out.replace(/^---.*$/gm,
    "<hr style='border:none;border-top:1px solid #222;margin:8px 0'>");

  // color blocks
  out = out.replace(
    /\[color=([a-z]+)(.*?)\]([\s\S]*?)\[\/color\]/g,
    (_, c, mods, body) => {
      const style = [];
      if (colors[c]) style.push(`color:${colors[c]}`);
      if (mods.includes("bold")) style.push("font-weight:650");
      if (mods.includes("dim")) style.push("opacity:.6");
      return `<span style="${style.join(";")}">${body}</span>`;
    }
  );

  // IMPORTANT: render actual newlines as <br>
  return out.replace(/\n/g, "<br>");
}

/* ===== BYTECODE EXEC ===== */
function execute(code) {
  // TERM <id> [TEXT|FORMAT] <<EOF ... EOF
  const m = code.match(/TERM\s+(\d+)(?:\s+(TEXT|FORMAT))?\s+<<EOF\s*([\s\S]*?)\s*EOF/);
  if (!m) return;

  const id = m[1];
  const mode = m[2] || "TEXT";

  // Transport decode here
  const content = decodeEscapes(m[3]);

  const term = terminals[id];
  if (!term) return;

  if (mode === "FORMAT") {
    term.innerHTML = renderFormat(content);
  } else {
    term.textContent = content;
  }
}

/* ===== NODE ===== */
function createNode(id, x, y) {
  const n = document.createElement("div");
  n.className = "node";
  n.style.left = x + "px";
  n.style.top = y + "px";
  n.style.zIndex = ++z;

  const h = document.createElement("div");
  h.className = "node-header";
  h.innerHTML = `node ${id} · linux <div class="controls"><span>–</span><span>▢</span><span>×</span></div>`;

  const t = document.createElement("div");
  t.className = "terminal";
  t.textContent = `user@node${id}:~$ `;

  n.append(h, t);
  canvas.appendChild(n);
  terminals[id] = t;

  // focus on click
  n.addEventListener("mousedown", () => focusNode(n));

  // drag header
  h.onmousedown = e => {
    focusNode(n);
    const ox = e.clientX - n.offsetLeft;
    const oy = e.clientY - n.offsetTop;

    document.onmousemove = e2 => {
      n.style.left = (e2.clientX - ox) + "px";
      n.style.top = (e2.clientY - oy) + "px";
    };
    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
}

function focusNode(n) {
  document.querySelectorAll(".node").forEach(x => x.classList.remove("focused"));
  n.classList.add("focused");
  n.style.zIndex = ++z;
}

/* ===== Input ===== */
input.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    execute(input.value);
    input.value = "";
  }
});

/* ===== INIT ===== */
createNode(1, 60, 70);
createNode(2, 480, 130);
createNode(3, 260, 420);
</script>

</body>
</html>
