<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flux Desk</title>

<style>
:root {
  --bg: #0b0e13;
  --panel: #141821;
  --panel-hi: #1b2130;
  --text: #d6d8dc;
  --muted: #8b90a0;
  --accent: #5eead4;
}

* { box-sizing: border-box; }

html, body {
  margin: 0;
  height: 100%;
  background: radial-gradient(1200px at top, #10151f, #080a0f);
  color: var(--text);
  font-family: system-ui, -apple-system, Segoe UI, sans-serif;
  overflow: hidden;
}

/* ===== Command Rail ===== */
#rail {
  height: 46px;
  background: linear-gradient(180deg, #141821, #0f131b);
  display: flex;
  align-items: center;
  padding: 0 14px;
}

#rail span {
  color: var(--muted);
  margin-right: 12px;
  letter-spacing: 0.4px;
}

#bytecode {
  flex: 1;
  height: 28px;
  background: #07090d;
  color: var(--accent);
  border-radius: 8px;
  border: none;
  padding: 0 10px;
  font-family: monospace;
  outline: none;
}




/* ===== Window Animations ===== */
.node {
  position: absolute;
  width: 380px;
  height: 280px;
  background: linear-gradient(180deg, var(--panel-hi), var(--panel));
  border-radius: 18px;
  box-shadow:
    0 18px 40px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.03);
  display: flex;
  flex-direction: column;
  resize: both;
  overflow: hidden;
  transition:
    transform 220ms ease,
    opacity 180ms ease,
    width 220ms ease,
    height 220ms ease,
    left 220ms ease,
    top 220ms ease;
}

.node.dragging {
  transition: none !important;
}


.node.minimized {
  transform: scale(0.92) translateY(20px);
  opacity: 0;
  pointer-events: none;
}

.node.closing {
  transform: scale(0.85);
  opacity: 0;
}


.node.focused {
  box-shadow:
    0 0 16px rgba(104,103,101,.35),
    0 30px 60px rgba(0,0,0,.75);
}

/* ===== Header ===== */
.node-header {
  height: 36px;
  background: linear-gradient(180deg, #1f2534, #151a25);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 14px;
  font-size: 13px;
  color: var(--muted);
  cursor: move;
  user-select: none;
}

.controls span {
  margin-left: 10px;
  font-family: monospace;
  cursor: pointer;
  opacity: .6;
}
.controls span:hover { opacity: 1; }

/* ===== Terminal ===== */
.terminal {
  flex: 1;
  background: radial-gradient(900px at top, #05070c, #000);
  color: var(--text);
  font-family: monospace;
  font-size: 13px;
  padding: 14px;
  overflow-y: auto;
}

/* ===== Canvas ===== */
#canvas {
  position: absolute;
  top: 46px;
  bottom: 0;
  left: 0;
  right: 0;

  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

/* ===== App Menu ===== */
.app-menu {
  position: absolute;
  top: 46px;
  left: 12px;
  width: 200px;
  background: linear-gradient(180deg, #1b2130, #141821);
  border-radius: 12px;
  box-shadow: 0 20px 50px rgba(0,0,0,.6);
  padding: 8px;
  z-index: 1000;
  animation: menuIn 160ms ease;
}

.app-menu.hidden {
  display: none;
}

.app-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  color: var(--text);
}

.app-item:hover {
  background: var(--panel-hi);
}

@keyframes menuIn {
  from { transform: translateY(6px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}


</style>
</head>

<body>

<div id="rail">
  <span id="fluxBtn" style="cursor:pointer">flux</span>
  <span id="wallpaperBtn" style="cursor:pointer">wallpaper</span>
  <input id="bytecode" placeholder="TERM 1 FORMAT <<EOF ... (use \\n for newlines)">
</div>

<div id="appMenu" class="app-menu hidden">
  <div class="app-item" data-app="terminal">Terminal</div>
  <div class="app-item" data-app="editor">Text Editor</div>
  <div class="app-item" data-app="viewer">Text Viewer</div>

</div>


<input
  id="wallpaperPicker"
  type="file"
  accept="image/*"
  style="display:none"
/>


<div id="canvas"></div>

<script>

let OPENAI_KEY = null;

async function getApiKey() {
  if (OPENAI_KEY) return OPENAI_KEY;

  const key = prompt("Enter your OpenAI API key:");
  if (!key) throw new Error("No API key provided");

  OPENAI_KEY = key.trim();
  return OPENAI_KEY;
}


async function callOpenAI(promptText) {
  const apiKey = await getApiKey();

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: "gpt-5-nano",
      messages: [
        {
          role: "system",
          content:
            "You are an operating system coprocessor that generates Flux bytecode. Flux is a minimal bytecode language used to update window nodes in a browser OS.\n\nA Flux command MUST have EXACTLY the following form:\nNODE <id> [options] <MODE> <<EOF\n<content>\nEOF\n\nThe heredoc opener MUST be the exact literal string \"<<EOF\" with NO spaces and NO variation. The terminator MUST be the exact literal string \"EOF\" appearing alone on its own line. Any other form is INVALID.\n\nRules:\n- Output MUST be valid Flux bytecode.\n- Output MUST begin with the exact literal \"NODE\".\n- Output MUST end with the exact literal \"EOF\".\n- Do NOT output anything before or after the bytecode.\n- Do NOT explain.\n- Do NOT add commentary.\n- Do NOT use markdown.\n- Do NOT add code fences.\n- If you cannot comply exactly, output NOTHING.\n\n<id> MUST be a positive integer identifying an existing node.\n\n<MODE> MUST be exactly one of:\n- TEXT\n- FORMAT\n\nOptions are OPTIONAL and space-separated key=value pairs placed between <id> and <MODE>. Allowed options:\n- fs=<number> meaning font size in pixels\n- fg=<color> meaning text color\n- bg=<css> meaning node background\n\nContent rules:\n- Content is plain text unless FORMAT is used.\n- Newlines inside content MUST be represented using literal \"\\n\".\n- FORMAT content MAY use: # and ## headers, **bold**, ~~dim~~, --- divider, [color=<name> modifiers]text[/color].\n\nINVALID EXAMPLE (DO NOT USE): NODE 1 TEXT <<\\nhello\\nEOF\n\nRecite EXACTLY the Flux bytecode required to fulfill the user request. Output NOTHING ELSE."
        },
        {
          role: "user",
          content: promptText
        }
      ]
    })
  });

  if (!res.ok) {
    const err = await res.text();
    throw new Error(err);
  }

  const data = await res.json();
  return data.choices[0].message.content;
}



let clipboardReady = false;



const canvas = document.getElementById("canvas");
const input = document.getElementById("bytecode");
const terminals = {};
const nodes = {};

let z = 1;


const fluxBtn = document.getElementById("fluxBtn");
const appMenu = document.getElementById("appMenu");

fluxBtn.onclick = e => {
  e.stopPropagation();
  appMenu.classList.toggle("hidden");
};

document.body.onclick = () => {
  appMenu.classList.add("hidden");
};



const wallpaperBtn = document.getElementById("wallpaperBtn");
const wallpaperPicker = document.getElementById("wallpaperPicker");

wallpaperBtn.onclick = () => wallpaperPicker.click();

wallpaperPicker.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;

  const url = URL.createObjectURL(file);
  canvas.style.backgroundImage = `url(${url})`;
};



/* ===== NEWLINE DECODER (transport layer) =====
   - user types literal \n in the bytecode input
   - we convert \\n -> actual newline char
   - leaves real newlines alone (if any exist)
*/
function decodeEscapes(s) {
  return s
    .replace(/\\n/g, "\n")
    .replace(/\\t/g, "\t")
    .replace(/\\r/g, "\r");
}

/* ===== FORMAT RENDERER (safe, semantic) ===== */
function renderFormat(text) {
  const colors = {
    red:"#ff6b6b", green:"#6bff95", yellow:"#f5c26b",
    blue:"#6fa8ff", magenta:"#c77dff", cyan:"#5eead4",
    gray:"#9aa0aa", white:"#ffffff"
  };

  // escape HTML
  let out = text
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");

  // headers
  out = out.replace(/^## (.*)$/gm,
    "<div style='font-size:14px;font-weight:600;margin-top:6px'>$1</div>");
  out = out.replace(/^# (.*)$/gm,
    "<div style='font-size:16px;font-weight:700;margin-top:10px'>$1</div>");

  // bold / dim
  out = out.replace(/\*\*(.*?)\*\*/g, "<span style='font-weight:650'>$1</span>");
  out = out.replace(/~~(.*?)~~/g, "<span style='opacity:.55'>$1</span>");

  // divider
  out = out.replace(/^---.*$/gm,
    "<hr style='border:none;border-top:1px solid #222;margin:8px 0'>");

  // color blocks
  out = out.replace(
    /\[color=([a-z]+)(.*?)\]([\s\S]*?)\[\/color\]/g,
    (_, c, mods, body) => {
      const style = [];
      if (colors[c]) style.push(`color:${colors[c]}`);
      if (mods.includes("bold")) style.push("font-weight:650");
      if (mods.includes("dim")) style.push("opacity:.6");
      return `<span style="${style.join(";")}">${body}</span>`;
    }
  );

  // IMPORTANT: render actual newlines as <br>
  return out.replace(/\n/g, "<br>");
}




function minimizeNode(n) {
  if (n._state.minimized) return;
  n._state.minimized = true;
  n.classList.add("minimized");
}

function toggleMaximize(n) {
  if (!n._state.maximized) {
    n._state.prev = {
      left: n.style.left,
      top: n.style.top,
      width: n.style.width,
      height: n.style.height
    };

    n.style.left = "0px";
    n.style.top = "0px";
    n.style.width = "100%";
    n.style.height = "calc(100%)";
    n.style.resize = "none";

    n._state.maximized = true;
  } else {
    const p = n._state.prev;
    if (p) {
      n.style.left = p.left;
      n.style.top = p.top;
      n.style.width = p.width;
      n.style.height = p.height;
    }
    n.style.resize = "both";
    n._state.maximized = false;
  }
}

function closeNode(n) {
  n.classList.add("closing");
  setTimeout(() => {
    delete terminals[n.dataset?.id];
    n.remove();
  }, 180);
}






function parseOptions(str) {
  if (!str) return {};
  return Object.fromEntries(
    str.split(/\s+/).map(p => {
      const [k, v] = p.split("=");
      return [k, v];
    })
  );
}





/* ===== BYTECODE EXEC ===== */
function execute(code) {
  // NODE <id> [TEXT|FORMAT] <<EOF ... EOF
  const m = code.match(
  /NODE\s+(\d+)((?:\s+[a-z]+=[^\s<]+)*)\s*(TEXT|FORMAT)?\s+<<EOF\s*([\s\S]*?)\s*EOF/
);


  if (!m) return;

  const id = m[1];
  const opts = parseOptions(m[2].trim());
  const mode = m[3] || "TEXT";
  const content = decodeEscapes(m[4]);




  const node = nodes[id];
  if (!node || !node._content) return;
  
  

  if (opts.bg) {
    node.style.background = opts.bg;
  }

  if (opts.fg) {
    node._content.style.color = opts.fg;
  }

  if (opts.fs) {
    node._content.style.fontSize = opts.fs + "px";
  }



  if (mode === "FORMAT") {
    node._content.innerHTML = renderFormat(content);
  } else {
    node._content.value !== undefined
      ? node._content.value = content
      : node._content.textContent = content;
  }

}



const apps = {
  terminal() {
    spawnTerminal();
  },
  editor() {
    spawnEditor();
  },
  viewer() {
    spawnTextViewer();
  }
};


document.querySelectorAll(".app-item").forEach(item => {
  item.onclick = e => {
    e.stopPropagation();
    const app = item.dataset.app;
    appMenu.classList.add("hidden");
    apps[app]?.();
  };
});



function spawnTerminal() {
  const id = Object.keys(terminals).length + 1;
  const n = createNode(id, 120 + id * 20, 100 + id * 20);

  n._content.textContent = `user@node${id}:~$ `;
}


function spawnTextViewer() {
  const id = Object.keys(terminals).length + 1;
  const n = createNode(id, 200, 160);

  const viewer = document.createElement("div");
  viewer.style.width = "100%";
  viewer.style.height = "100%";
  viewer.style.overflowY = "auto";
  viewer.style.whiteSpace = "pre-wrap";
  viewer.style.fontFamily = "monospace";
  viewer.style.padding = "14px";
  viewer.style.color = "var(--text)";
  viewer.textContent = "Text Viewer ready.\n\nLoad content via bytecode.";

  n._content.replaceWith(viewer);
  n._content = viewer;
}



function spawnEditor() {
  const id = Object.keys(terminals).length + 1;
  const n = createNode(id, 160, 140);

  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.height = "100%";
  textarea.style.background = "transparent";
  textarea.style.color = "var(--text)";
  textarea.style.border = "none";
  textarea.style.resize = "none";
  textarea.style.outline = "none";
  textarea.style.fontFamily = "monospace";
  textarea.placeholder = "Start typing…";

  n._content.replaceWith(textarea);
  n._content = textarea;
}



function enableDrag(n, h) { /* existing drag logic */ }
function wireControls(n, h) { /* minimize/max/close logic */ }



/* ===== NODE ===== */
function createNode(id, x, y) {
  const n = document.createElement("div");
  n.className = "node";
  n.style.left = x + "px";
  n.style.top = y + "px";
  n.style.zIndex = ++z;

  const h = document.createElement("div");
  h.className = "node-header";
  h.innerHTML = `
    node ${id} · linux
    <div class="controls">
      <span data-action="min">–</span>
      <span data-action="max">▢</span>
      <span data-action="close">×</span>
    </div>
  `;


  const t = document.createElement("div");
  t.className = "terminal";


  n._state = {
    minimized: false,
    maximized: false,
    prev: null
  };


  n.append(h, t);
  canvas.appendChild(n);
  terminals[id] = t;
  n._content = t;
  nodes[id] = n;


  // focus on click
  n.addEventListener("mousedown", () => focusNode(n));

  // drag header
  h.onmousedown = e => {
    focusNode(n);

    // Disable animations while dragging
    n.classList.add("dragging");

    const ox = e.clientX - n.offsetLeft;
    const oy = e.clientY - n.offsetTop;

    document.onmousemove = e2 => {
      n.style.left = (e2.clientX - ox) + "px";
      n.style.top = (e2.clientY - oy) + "px";
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;

      // Re-enable animations after drag
      n.classList.remove("dragging");
    };
  };

  
  h.querySelectorAll(".controls span").forEach(btn => {
    btn.onclick = e => {
      e.stopPropagation();
      const action = btn.dataset.action;

      if (action === "min") minimizeNode(n);
      if (action === "max") toggleMaximize(n);
      if (action === "close") closeNode(n);
    };
  });
  return n;

}

function focusNode(n) {
  document.querySelectorAll(".node").forEach(x => x.classList.remove("focused"));
  n.classList.add("focused");
  n.style.zIndex = ++z;
  
  if (n._state.minimized) {
    n._state.minimized = false;
    n.classList.remove("minimized");
  }

}

/* ===== Input ===== */
input.addEventListener("keydown", async e => {
  if (e.key !== "Enter") return;

  const text = input.value.trim();
  input.value = "";

  // If it starts with AI, route to OpenAI
  if (text.startsWith("AI ")) {
    try {
      const prompt = text.slice(3);
      const aiByteCode = await callOpenAI(prompt);
      console.log(aiByteCode)
      execute(aiByteCode);
    } catch (err) {
      alert("AI error:\n" + err.message);
    }
  } else {
    execute(text);
  }
});




document.addEventListener("dblclick", async e => {
  const tag = e.target.tagName;
  if (tag === "INPUT" || tag === "TEXTAREA") return;

  try {
    // First run: this triggers permission prompt
    const text = await navigator.clipboard.readText();
    clipboardReady = true;

    if (!text.trim()) return;

    execute(text);
  } catch (err) {
    console.warn("Clipboard blocked:", err);
    alert("Allow clipboard access to enable double-click execution.");
  }
});

console.log("Clipboard execution requires HTTPS or localhost.");


</script>

</body>
</html>
